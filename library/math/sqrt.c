/*
 * $Id: math_sqrt.c,v 1.12 2021-01-31 07:54:24 clib2devs Exp $
*/

#ifndef _MATH_HEADERS_H

#include "math_headers.h"

#endif /* _MATH_HEADERS_H */

static const double one = 1.0, tiny = 1.0e-300;

#if __BYTE_ORDER__ == __BIG_ENDIAN__
static const mynumber
/**/           t512 = {{0x5ff00000, 0x00000000}},  /* 2^512  */
/**/          tm256 = {{0x2ff00000, 0x00000000}};  /* 2^-256 */

#else
static const mynumber
/**/           t512 = {{0x00000000, 0x5ff00000 }}, /* 2^512  */
/**/          tm256 = {{0x00000000, 0x2ff00000 }}; /* 2^-256 */
#endif

#ifndef __SPE__
double
sqrt(double x) {
    double z;
    int32_t sign = (int) 0x80000000;
    int32_t ix0, s0, q, m, t, i;
    uint32_t r, t1, s1, ix1, q1;

    EXTRACT_WORDS(ix0, ix1, x);

    /* take care of Inf and NaN */
    if ((ix0 & 0x7ff00000) == 0x7ff00000) {
        return x * x + x;        /* sqrt(NaN)=NaN, sqrt(+inf)=+inf
					   sqrt(-inf)=sNaN */
    }
    /* take care of zero */
    if (ix0 <= 0) {
        if (((ix0 & (~sign)) | ix1) == 0) return x;/* sqrt(+-0) = +-0 */
        else if (ix0 < 0)
            return (x - x) / (x - x);        /* sqrt(-ve) = sNaN */
    }
    /* normalize x */
    m = (ix0 >> 20);
    if (m == 0) {                /* subnormal x */
        while (ix0 == 0) {
            m -= 21;
            ix0 |= (ix1 >> 11);
            ix1 <<= 21;
        }
        for (i = 0; (ix0 & 0x00100000) == 0; i++) ix0 <<= 1;
        m -= i - 1;
        ix0 |= (ix1 >> (32 - i));
        ix1 <<= i;
    }
    m -= 1023;    /* unbias exponent */
    ix0 = (ix0 & 0x000fffff) | 0x00100000;
    if (m & 1) {    /* odd m, double x to make it even */
        ix0 += ix0 + ((ix1 & sign) >> 31);
        ix1 += ix1;
    }
    m >>= 1;    /* m = [m/2] */

    /* generate sqrt(x) bit by bit */
    ix0 += ix0 + ((ix1 & sign) >> 31);
    ix1 += ix1;
    q = q1 = s0 = s1 = 0;    /* [q,q1] = sqrt(x) */
    r = 0x00200000;        /* r = moving bit from right to left */

    while (r != 0) {
        t = s0 + r;
        if (t <= ix0) {
            s0 = t + r;
            ix0 -= t;
            q += r;
        }
        ix0 += ix0 + ((ix1 & sign) >> 31);
        ix1 += ix1;
        r >>= 1;
    }

    r = sign;
    while (r != 0) {
        t1 = s1 + r;
        t = s0;
        if ((t < ix0) || ((t == ix0) && (t1 <= ix1))) {
            s1 = t1 + r;
            if (((t1 & sign) == sign) && (s1 & sign) == 0) s0 += 1;
            ix0 -= t;
            if (ix1 < t1) ix0 -= 1;
            ix1 -= t1;
            q1 += r;
        }
        ix0 += ix0 + ((ix1 & sign) >> 31);
        ix1 += ix1;
        r >>= 1;
    }

    /* use floating add to find out rounding direction */
    if ((ix0 | ix1) != 0) {
        z = one - tiny; /* trigger inexact flag */
        if (z >= one) {
            z = one + tiny;
            if (q1 == (uint32_t) 0xffffffff) {
                q1 = 0;
                q += 1;
            } else if (z > one) {
                if (q1 == (uint32_t) 0xfffffffe) q += 1;
                q1 += 2;
            } else
                q1 += (q1 & 1);
        }
    }
    ix0 = (q >> 1) + 0x3fe00000;
    ix1 = q1 >> 1;
    if ((q & 1) == 1) ix1 |= sign;
    ix0 += (m << 20);
    INSERT_WORDS(z, ix0, ix1);
    return z;
}

#else
static const double inroot[128] = {
  1.40872145012100,  1.39792649065766,  1.38737595123859,  1.37706074531819,
  1.36697225234682,  1.35710228748795,  1.34744307370643,  1.33798721601135,
  1.32872767765984,  1.31965775814772,  1.31077107283046,  1.30206153403386,
  1.29352333352711,  1.28515092624400,  1.27693901514820,  1.26888253714903,
  1.26097664998256,  1.25321671998073,  1.24559831065844,  1.23811717205462,
  1.23076923076923,  1.22355058064300,  1.21645747403153,  1.20948631362953,
  1.20263364480453,  1.19589614840310,  1.18927063399547,  1.18275403352732,
  1.17634339535009,  1.17003587860341,  1.16382874792529,  1.15771936846787,
  1.15170520119791,  1.14578379846309,  1.13995279980655,  1.13420992801334,
  1.12855298537376,  1.12297985014975,  1.11748847323133,  1.11207687497107,
  1.10674314218572,  1.10148542531442,  1.09630193572405,  1.09119094315276,
  1.08615077328341,  1.08117980543918,  1.07627647039410,  1.07143924829188,
  1.06666666666667,  1.06195729855996,  1.05730976072814,  1.05272271193563,
  1.04819485132867,  1.04372491688551,  1.03931168393861,  1.03495396376504,
  1.03065060224133,  1.02640047855933,  1.02220250399990,  1.01805562076124,
  1.01395880083916,  1.00991104495649,  1.00591138153909,  1.00195886573624,
  0.99611649018350,  0.98848330114434,  0.98102294317595,  0.97372899112030,
  0.96659534932828,  0.95961623024651,  0.95278613468066,  0.94609983358253,
  0.93955235122353,  0.93313894963169,  0.92685511418159,  0.92069654023750,
  0.91465912076005,  0.90873893479530,  0.90293223677296,  0.89723544654727,
  0.89164514012056,  0.88615804099474,  0.88077101210109,  0.87548104826333,
  0.87028526915267,  0.86518091269740,  0.86016532891275,  0.85523597411976,
  0.85039040552437,  0.84562627613070,  0.84094132996422,  0.83633339758291,
  0.83180039185606,  0.82734030399203,  0.82295119979782,  0.81863121615464,
  0.81437855769486,  0.81019149366693,  0.80606835497581,  0.80200753138734,
  0.79800746888611,  0.79406666717674,  0.79018367731967,  0.78635709949278,
  0.78258558087123,  0.77886781361798,  0.77520253297841,  0.77158851547266,
  0.76802457717971,  0.76450957210799,  0.76104239064719,  0.75762195809661,
  0.75424723326565,  0.75091720714229,  0.74763090162560,  0.74438736831878,
  0.74118568737933,  0.73802496642311,  0.73490433947940,  0.73182296599416,
  0.72878002987884,  0.72577473860242,  0.72280632232420,  0.71987403306536,
  0.71697714391715,  0.71411494828392,  0.71128675915902,  0.70849190843208 };


double
sqrt(double x) {
    static const double
            rt0 = 9.99999999859990725855365213134618E-01,
            rt1 = 4.99999999495955425917856814202739E-01,
            rt2 = 3.75017500867345182581453026130850E-01,
            rt3 = 3.12523626554518656309172508769531E-01;
    static const double big = 134217728.0;
    double y, t, del, res, res1, hy, z, zz, p, hx, tx, ty, s;
    mynumber a, c = {{0, 0}};
    int4 k;

    a.x = x;
    k = a.i[HIGH_HALF];
    a.i[HIGH_HALF] = (k & 0x001fffff) | 0x3fe00000;
    t = inroot[(k & 0x001fffff) >> 14];
    s = a.x;
    /*----------------- 2^-1022  <= | x |< 2^1024  -----------------*/
    if (k > 0x000fffff && k < 0x7ff00000) {
        y = 1.0 - t * (t * s);
        t = t * (rt0 + y * (rt1 + y * (rt2 + y * rt3)));
        c.i[HIGH_HALF] = 0x20000000 + ((k & 0x7fe00000) >> 1);
        y = t * s;
        hy = (y + big) - big;
        del = 0.5 * t * ((s - hy * hy) - (y - hy) * (y + hy));
        res = y + del;
        if (res == (res + 1.002 * ((y - res) + del))) return res * c.x;
        else {
            res1 = res + 1.5 * ((y - res) + del);
            EMULV(res, res1, z, zz, p, hx, tx, hy, ty);  /* (z+zz)=res*res1 */
            return ((((z - s) + zz) < 0) ? MAX(res, res1) : MIN(res, res1)) * c.x;
        }
    } else {
        if ((k & 0x7ff00000) == 0x7ff00000)
            return x * x + x;    /* sqrt(NaN)=NaN, sqrt(+inf)=+inf, sqrt(-inf)=sNaN */
        if (x == 0) return x;    /* sqrt(+0)=+0, sqrt(-0)=-0 */
        if (k < 0) return (x - x) / (x - x); /* sqrt(-ve)=sNaN */
        return tm256.x * sqrt(x * t512.x);
    }
}

#endif